import * as z from "zod";
import {
    AgentMessage,
    BaseMessage,
    MessageContent,
    ModelMessages,
    SystemMessage,
    ToolRequest,
} from "../messages";
import { ToolDefinition } from "../tools";

/**
 * Configuration options for model initialization.
 * 
 * @interface BaseModelConfig
 * @property {number} [temperature] - Controls randomness/creativity (0-1). Lower = more deterministic
 * @property {number} [topP] - Nucleus sampling parameter (0-1). Controls diversity of output
 * @property {number} [maxTokens] - Maximum number of tokens in the response
 */
export interface BaseModelConfig {
    temperature?: number;
    topP?: number;
    maxTokens?: number;
}

/**
 * Token usage information for a model invocation.
 * 
 * @interface InvokeResponseUsage
 * @property {number} inputTokens - Number of tokens in the input/prompt
 * @property {number} outputTokens - Number of tokens in the output/response
 */
export interface InvokeResponseUsage {
    inputTokens: number;
    outputTokens: number;
}

/**
 * Enum representing the reason why model generation stopped.
 * 
 * @enum {string}
 * @property {string} UNKNOWN - Stop reason is not determined
 * @property {string} STOP_SEQUENCE - Generation ended at a stop sequence
 * @property {string} MAX_TOKENS - Generation reached maximum token limit
 * @property {string} END_TURN - Model indicated end of turn
 * @property {string} TOOL_USE - Generation stopped to request tool use
 */
export enum InvokeResponseStopReason {
    UNKNOWN = "unknown",
    STOP_SEQUENCE = "stop_sequence",
    MAX_TOKENS = "max_tokens",
    END_TURN = "end_turn",
    TOOL_USE = "tool_use",
}

/**
 * Response from invoking a model.
 * 
 * @interface InvokeResponse
 * @property {(AgentMessage | ToolRequest)[]} messages - Messages generated by the model
 * @property {InvokeResponseUsage} usage - Token usage statistics
 * @property {InvokeResponseStopReason} [stopReason] - Reason why generation stopped
 */
export interface InvokeResponse {
    messages: (AgentMessage | ToolRequest)[];
    usage: InvokeResponseUsage;
    stopReason?: InvokeResponseStopReason;
}

/**
 * Abstract base class for AI model implementations.
 * Provides common functionality for configuring and invoking models.
 * Subclasses must implement runModel() for specific model providers.
 * 
 * @abstract
 * @example
 * ```typescript
 * class MyCustomModel extends BaseModel {
 *   protected async runModel(messages: ModelMessages[]): Promise<InvokeResponse> {
 *     // Implementation specific to your model provider
 *   }
 * }
 * 
 * const model = new MyCustomModel({ temperature: 0.7 })
 *   .withSystemMessage("You are a helpful assistant")
 *   .withTools([searchTool, calculatorTool]);
 * 
 * const response = await model.invoke([userMessage]);
 * ```
 */
export abstract class BaseModel {
    protected temperature?: number;
    protected topP?: number;
    protected maxTokens?: number;

    protected systemMessage?: SystemMessage;
    protected tools: ToolDefinition[] = [];
    protected structuredOutput?: z.ZodSchema<any>;

    /**
     * Creates a new model instance with the provided configuration.
     * Configuration values are clamped to valid ranges.
     * 
     * @param {BaseModelConfig} config - Model configuration
     */
    constructor(config: BaseModelConfig) {
        if (config.temperature) {
            this.temperature = Math.max(0, Math.min(1, config.temperature));
        }
        if (config.topP) {
            this.topP = Math.max(0, Math.min(1, config.topP));
        }
        if (config.maxTokens) {
            this.maxTokens = Math.max(0, config.maxTokens);
        }
    }

    /**
     * Sets the system message for the model.
     * The system message provides context and instructions for the model's behavior.
     * 
     * @param {SystemMessage | MessageContent} message - The system message
     * @returns {this} The model instance for method chaining
     * 
     * @example
     * ```typescript
     * model.withSystemMessage("You are an expert Python developer");
     * ```
     */
    withSystemMessage(message: SystemMessage | MessageContent): this {
        if (message instanceof SystemMessage) {
            this.systemMessage = message;
        } else {
            this.systemMessage = new SystemMessage(message);
        }
        return this;
    }

    /**
     * Sets the tools available to the model.
     * Cannot be combined with structured output.
     * 
     * @param {ToolDefinition[]} tools - Array of tool definitions
     * @returns {this} The model instance for method chaining
     * @throws {Error} If structured output is already configured
     * 
     * @example
     * ```typescript
     * model.withTools([webSearchTool, calculatorTool]);
     * ```
     */
    withTools(tools: ToolDefinition[]): this {
        if (this.structuredOutput) {
            throw new Error("Cannot set tools with structured output");
        }
        this.tools = tools;
        return this;
    }

    /**
     * Configures structured output using a Zod schema.
     * The model will be forced to output data matching this schema.
     * Cannot be combined with tools.
     * 
     * @template T - The Zod schema type
     * @param {T} schema - Zod schema defining the output structure
     * @returns {StructuredOutputWrapper<T>} A wrapper for invoking with structured output
     * @throws {Error} If tools are already configured
     * 
     * @example
     * ```typescript
     * const schema = z.object({
     *   sentiment: z.enum(["positive", "negative", "neutral"]),
     *   confidence: z.number().min(0).max(1)
     * });
     * const wrapper = model.withStructuredOutput(schema);
     * const result = await wrapper.invoke(messages);
     * ```
     */
    withStructuredOutput<T extends z.ZodObject>(
        schema: T,
    ): StructuredOutputWrapper<T> {
        this.tools = [];
        this.structuredOutput = schema;
        return new StructuredOutputWrapper<T>(this, schema);
    }

    /**
     * Internal method to run the model implementation.
     * Must be implemented by subclasses.
     * 
     * @protected
     * @abstract
     * @param {ModelMessages[]} messages - Messages to send to the model
     * @returns {Promise<InvokeResponse>} The model's response
     */
    protected abstract runModel(
        messages: ModelMessages[],
    ): Promise<InvokeResponse>;

    /**
     * Invokes the model with messages and optional template variable substitution.
     * Messages can contain template variables like {name} that will be replaced
     * with values from the properties object.
     * 
     * @param {ModelMessages[]} messages - Messages to send to the model
     * @param {Record<string, any>} [properties] - Optional property values for template substitution
     * @returns {Promise<InvokeResponse>} The model's response
     * @throws {Error} If a template variable is not found in properties
     * 
     * @example
     * ```typescript
     * const response = await model.invoke(
     *   [new UserMessage("Hello, my name is {name}")],
     *   { name: "Alice" }
     * );
     * ```
     */
    async invoke(
        messages: ModelMessages[],
        properties?: Record<string, any>,
    ): Promise<InvokeResponse> {
        if (!properties) {
            return this.runModel(messages);
        }
        return this.runModel(messages.map((message) => {
            if (message instanceof BaseMessage) {
                message.interpolate(properties);
            }
            return message;
        }));
    }
}

/**
 * Error thrown when response is not structured output as expected.
 * 
 * @class ResponseNotStructuredOutputError
 * @extends {Error}
 */
export class ResponseNotStructuredOutputError extends Error {
    /**
     * Creates a new error instance.
     */
    constructor() {
        super("Response is not structured output");
        this.name = "ResponseNotStructuredOutputError";
    }
}

/**
 * Wrapper class for models configured with structured output.
 * Ensures responses conform to the specified Zod schema.
 * 
 * @template T - The Zod schema type
 * 
 * @example
 * ```typescript
 * const schema = z.object({ message: z.string(), score: z.number() });
 * const wrapper = model.withStructuredOutput(schema);
 * const parsed = await wrapper.invoke(messages);
 * // parsed is guaranteed to match the schema type
 * ```
 */
export class StructuredOutputWrapper<T extends z.ZodObject> {
    /**
     * Creates a wrapper for structured output.
     * 
     * @param {BaseModel} model - The model instance
     * @param {T} schema - The output schema
     */
    constructor(private readonly model: BaseModel, private readonly schema: T) { }

    /**
     * Sets the system message for this model instance.
     * 
     * @param {SystemMessage | MessageContent} message - The system message
     * @returns {this} The wrapper instance for method chaining
     */
    withSystemMessage(message: SystemMessage | MessageContent): this {
        this.model.withSystemMessage(message);
        return this;
    }

    /**
     * Invokes the model and parses the response using the configured schema.
     * The model is forced to call an "output" tool containing the structured data.
     * 
     * @param {ModelMessages[]} messages - Messages to send to the model
     * @param {Record<string, any>} [properties] - Optional template variables
     * @returns {Promise<z.infer<T>>} The parsed response matching the schema
     * @throws {ResponseNotStructuredOutputError} If response doesn't match expected format
     * 
     * @example
     * ```typescript
     * const result = await wrapper.invoke([userMessage]);
     * console.log(result.message); // TypeScript knows this is a string
     * console.log(result.score);   // TypeScript knows this is a number
     * ```
     */
    async invoke(
        messages: ModelMessages[],
        properties?: Record<string, any>,
    ): Promise<z.infer<T>> {
        const response = await this.model.invoke(messages, properties);
        if (!response.messages.length) {
            throw new ResponseNotStructuredOutputError();
        }
        if (!(response.messages[0] instanceof ToolRequest)) {
            throw new ResponseNotStructuredOutputError();
        }
        const toolRequest = response.messages[0] as ToolRequest;
        return this.schema.parse(toolRequest.input);
    }
}
